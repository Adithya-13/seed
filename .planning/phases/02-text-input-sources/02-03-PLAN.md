---
phase: 02-text-input-sources
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified: [seed/Presentation/Views/InputSourcePicker.swift, seed/ContentView.swift]
autonomous: true

must_haves:
  truths:
    - "User can choose between paste/URL/PDF input methods"
    - "All three input methods load text into RSVP player"
  artifacts:
    - path: "seed/Presentation/Views/InputSourcePicker.swift"
      provides: "Multi-source input UI with tab/picker"
      min_lines: 50
    - path: "seed/ContentView.swift"
      provides: "Integration of all input sources"
      contains: "InputSourcePicker"
  key_links:
    - from: "InputSourcePicker"
      to: "URLArticleExtractor + PDFTextExtractor + TextInputView"
      via: "conditional view rendering based on source type"
      pattern: "switch.*inputSource"
    - from: "Extracted text"
      to: "TextValidator"
      via: "validation before RSVP load"
      pattern: "TextValidator.validate"
---

<objective>
Multi-source input UI integrating paste, URL, and PDF extraction into unified flow.

Purpose: Give users three text import options with seamless integration into existing RSVP flow.
Output: Complete input source selection UI integrated with ContentView.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plans in this phase (Wave 1)
@.planning/phases/02-text-input-sources/02-01-SUMMARY.md
@.planning/phases/02-text-input-sources/02-02-SUMMARY.md

# Phase 1 UI patterns
@.planning/phases/01-foundation-rsvp-engine/01-03-SUMMARY.md

# Existing code
@seed/ContentView.swift
@seed/Presentation/Views/TextInputView.swift
@seed/Data/TextValidator.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InputSourcePicker with tab UI</name>
  <files>seed/Presentation/Views/InputSourcePicker.swift</files>
  <action>
    Create input source picker with three tabs:

    ```swift
    import SwiftUI

    enum InputSource: String, CaseIterable {
        case paste = "Paste"
        case url = "URL"
        case pdf = "PDF"

        var icon: String {
            switch self {
            case .paste: return "doc.text"
            case .url: return "link"
            case .pdf: return "doc.fill"
            }
        }
    }

    struct InputSourcePicker: View {
        @State private var selectedSource: InputSource = .paste
        @State private var urlInput: String = ""
        @State private var extractedText: String = ""
        @State private var isLoading: Bool = false
        @State private var errorMessage: String?
        @State private var showDocumentPicker: Bool = false

        let urlExtractor = URLArticleExtractor()
        let pdfExtractor = PDFTextExtractor()

        let onTextReady: (String) -> Void

        var body: some View {
            VStack(spacing: 20) {
                // Tab selector
                Picker("Input Source", selection: $selectedSource) {
                    ForEach(InputSource.allCases, id: \.self) { source in
                        Label(source.rawValue, systemImage: source.icon)
                            .tag(source)
                    }
                }
                .pickerStyle(.segmented)
                .padding(.horizontal)

                // Content based on source
                Group {
                    switch selectedSource {
                    case .paste:
                        TextInputView(onTextReady: onTextReady)
                    case .url:
                        urlInputView
                    case .pdf:
                        pdfInputView
                    }
                }

                if isLoading {
                    ProgressView("Loading...")
                }

                if let error = errorMessage {
                    Text(error)
                        .foregroundColor(.red)
                        .font(.caption)
                }
            }
            .sheet(isPresented: $showDocumentPicker) {
                DocumentPickerView(contentTypes: PDFTextExtractor.supportedTypes) { url in
                    Task {
                        await extractPDF(from: url)
                    }
                }
            }
        }

        private var urlInputView: some View {
            VStack(spacing: 12) {
                TextField("Enter article URL", text: $urlInput)
                    .textFieldStyle(.roundedBorder)
                    .keyboardType(.URL)
                    .autocapitalization(.none)
                    .padding(.horizontal)

                Button("Extract Article") {
                    Task {
                        await extractURL()
                    }
                }
                .disabled(urlInput.isEmpty || isLoading)
                .buttonStyle(.borderedProminent)
            }
        }

        private var pdfInputView: some View {
            VStack(spacing: 12) {
                Text("Select a PDF file to extract text")
                    .font(.subheadline)
                    .foregroundColor(.secondary)

                Button("Choose PDF File") {
                    showDocumentPicker = true
                }
                .buttonStyle(.borderedProminent)
                .disabled(isLoading)
            }
        }

        private func extractURL() async {
            isLoading = true
            errorMessage = nil

            do {
                let text = try await urlExtractor.extract(from: urlInput)
                validateAndLoad(text)
            } catch {
                errorMessage = "Failed to extract article: \(error.localizedDescription)"
            }

            isLoading = false
        }

        private func extractPDF(from url: URL) async {
            isLoading = true
            errorMessage = nil

            do {
                let text = try await pdfExtractor.extractText(from: url)
                validateAndLoad(text)
            } catch {
                errorMessage = "Failed to extract PDF: \(error.localizedDescription)"
            }

            isLoading = false
        }

        private func validateAndLoad(_ text: String) {
            switch TextValidator.validate(text) {
            case .success(let validText):
                onTextReady(validText)
            case .failure(let error):
                errorMessage = "Validation failed: \(error.localizedDescription)"
            }
        }
    }
    ```

    Use segmented picker for source selection. Each source has dedicated UI.
    Reuse existing TextInputView for paste. URL/PDF have custom UIs.
    Validate all extracted text through TextValidator before passing to onTextReady.
  </action>
  <verify>Build succeeds, InputSourcePicker compiles</verify>
  <done>InputSourcePicker provides three input methods with validation</done>
</task>

<task type="auto">
  <name>Task 2: Update ContentView to use InputSourcePicker</name>
  <files>seed/ContentView.swift</files>
  <action>
    Replace existing TextInputView with InputSourcePicker in ContentView:

    ```swift
    // Before (Phase 1):
    if !hasLoadedText {
        TextInputView { text in
            viewModel.loadText(text)
            hasLoadedText = true
        }
    } else {
        // RSVP views...
    }

    // After (Phase 2):
    if !hasLoadedText {
        InputSourcePicker { text in
            viewModel.loadText(text)
            hasLoadedText = true
        }
    } else {
        // RSVP views (unchanged)
    }
    ```

    Simple drop-in replacement. InputSourcePicker internally handles paste/URL/PDF.
    Same callback interface: onTextReady provides validated text.
  </action>
  <verify>Build succeeds, app runs, segmented picker visible</verify>
  <done>ContentView integrates all three input sources</done>
</task>

<task type="auto">
  <name>Task 3: Manual verification of all input sources</name>
  <files>None (testing)</files>
  <action>
    Test all three input flows end-to-end:

    1. **Paste:** Switch to Paste tab, paste text, verify loads into RSVP
    2. **URL:** Switch to URL tab, enter article URL (e.g., news site), tap Extract, verify clean text loads
    3. **PDF:** Switch to PDF tab, tap Choose PDF, select test PDF, verify text loads

    For each: confirm TextValidator catches invalid input (too short/long).
    Confirm all three flows transition to RSVP playback correctly.
  </action>
  <verify>All three input methods work, text loads into RSVP player</verify>
  <done>Phase 2 requirements satisfied: paste, URL, PDF all functional</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] InputSourcePicker builds and displays three tabs
- [ ] Paste flow works (existing from Phase 1)
- [ ] URL flow extracts articles correctly
- [ ] PDF flow imports and extracts text
- [ ] All flows validate text before loading
- [ ] ContentView integrates seamlessly
</verification>

<success_criteria>

- All tasks completed
- User can choose between paste/URL/PDF input methods
- All three methods load text into RSVP player successfully
- TextValidator catches invalid input across all sources
- No errors or warnings introduced
- Phase 2 requirements (INPUT-02, INPUT-03, INPUT-04) satisfied
  </success_criteria>

<output>
After completion, create `.planning/phases/02-text-input-sources/02-03-SUMMARY.md`
</output>
