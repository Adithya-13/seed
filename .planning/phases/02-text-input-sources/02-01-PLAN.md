---
phase: 02-text-input-sources
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [seed/Data/URLArticleExtractor.swift]
autonomous: true

must_haves:
  truths:
    - "User can paste URL and see clean article text extracted"
  artifacts:
    - path: "seed/Data/URLArticleExtractor.swift"
      provides: "URL fetching and article extraction"
      exports: ["extract(from:)"]
  key_links:
    - from: "URLArticleExtractor"
      to: "ReadabilityKit + URLSession"
      via: "async article extraction"
---

<objective>
URL article extractor with ReadabilityKit for clean text extraction.

Purpose: Enable importing articles from web URLs with automatic extraction of main content (no nav/ads).
Output: URLArticleExtractor in Data layer ready for UI integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 established patterns
@.planning/phases/01-foundation-rsvp-engine/01-03-SUMMARY.md

# Existing code
@seed/Data/TextValidator.swift

Stack from Phase 1:
- Clean architecture (Data/Domain/Presentation)
- Result type for validation
- Async/await patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ReadabilityKit dependency</name>
  <files>seed.xcodeproj/project.pbxproj, Package.swift (if using SPM)</files>
  <action>
    Add ReadabilityKit via Swift Package Manager (https://github.com/exyte/ReadabilityKit).
    If project uses Xcode project directly: File → Add Package Dependencies → paste URL.
    Target: seed app target.
    Version: latest stable (likely 2.x).
  </action>
  <verify>Build succeeds, `import Readability` works in new file</verify>
  <done>ReadabilityKit dependency added and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create URLArticleExtractor with async extraction</name>
  <files>seed/Data/URLArticleExtractor.swift</files>
  <action>
    Create URLArticleExtractor class in Data layer:

    ```swift
    import Foundation
    import Readability

    enum URLExtractionError: Error {
        case invalidURL
        case networkError(Error)
        case extractionFailed
        case noContent
    }

    actor URLArticleExtractor {
        func extract(from urlString: String) async throws -> String {
            // 1. Validate URL
            guard let url = URL(string: urlString) else {
                throw URLExtractionError.invalidURL
            }

            // 2. Fetch HTML with URLSession
            let (data, _) = try await URLSession.shared.data(from: url)
            guard let html = String(data: data, encoding: .utf8) else {
                throw URLExtractionError.noContent
            }

            // 3. Extract article with ReadabilityKit
            let readability = Readability(url: url, html: html)
            guard let article = readability.parse() else {
                throw URLExtractionError.extractionFailed
            }

            // 4. Return clean text (strip HTML tags if needed)
            return article.textContent
        }
    }
    ```

    Use actor for thread-safe async operations. Return clean text suitable for RSVP.
    Error types match TextValidator pattern (Result-ready).
  </action>
  <verify>
    Build succeeds, no TypeScript errors.
    Manual test: await extractor.extract(from: "https://example-article.com") returns text.
  </verify>
  <done>URLArticleExtractor extracts clean article text from URLs</done>
</task>

<task type="auto">
  <name>Task 3: Add unit test for URLArticleExtractor</name>
  <files>seedTests/URLArticleExtractorTests.swift</files>
  <action>
    Create test file in seedTests group:

    ```swift
    import XCTest
    @testable import seed

    final class URLArticleExtractorTests: XCTestCase {
        func testExtractValidURL() async throws {
            let extractor = URLArticleExtractor()
            // Use a known stable test article URL or mock URLSession
            let text = try await extractor.extract(from: "https://example.com/article")
            XCTAssertFalse(text.isEmpty)
            XCTAssertGreaterThan(text.count, 100)
        }

        func testInvalidURL() async {
            let extractor = URLArticleExtractor()
            do {
                _ = try await extractor.extract(from: "not-a-url")
                XCTFail("Should throw invalidURL error")
            } catch URLExtractionError.invalidURL {
                // Expected
            } catch {
                XCTFail("Wrong error type")
            }
        }
    }
    ```

    Focus on error cases (invalid URL). For network tests, consider mocking URLSession or using local test HTML.
  </action>
  <verify>swift test or Cmd+U runs tests, all pass</verify>
  <done>URLArticleExtractor has basic test coverage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ReadabilityKit imported successfully
- [ ] URLArticleExtractor builds without errors
- [ ] Tests pass (at least error case validation)
- [ ] Manual test with real URL extracts clean text
</verification>

<success_criteria>

- All tasks completed
- URLArticleExtractor.extract(from:) works with real URLs
- Clean text output suitable for TextValidator → RSVP flow
- No errors or warnings introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/02-text-input-sources/02-01-SUMMARY.md`
</output>
