---
phase: 02-text-input-sources
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [seed/Data/PDFTextExtractor.swift]
autonomous: true

must_haves:
  truths:
    - "User can import PDF file and see text extracted correctly"
  artifacts:
    - path: "seed/Data/PDFTextExtractor.swift"
      provides: "PDF file selection and text extraction"
      exports: ["extract()"]
  key_links:
    - from: "PDFTextExtractor"
      to: "PDFKit + UIDocumentPickerViewController"
      via: "file selection and page text extraction"
---

<objective>
PDF text extractor with native PDFKit for file import and text extraction.

Purpose: Enable importing PDF files with text extraction across all pages.
Output: PDFTextExtractor in Data layer ready for UI integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 established patterns
@.planning/phases/01-foundation-rsvp-engine/01-03-SUMMARY.md

# Existing code
@seed/Data/TextValidator.swift

Stack from Phase 1:
- Clean architecture (Data/Domain/Presentation)
- Result type for validation
- SwiftUI + UIKit bridging where needed
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PDFTextExtractor with file picker</name>
  <files>seed/Data/PDFTextExtractor.swift</files>
  <action>
    Create PDFTextExtractor in Data layer using PDFKit (native, no external deps):

    ```swift
    import PDFKit
    import UniformTypeIdentifiers

    enum PDFExtractionError: Error {
        case fileAccessDenied
        case invalidPDF
        case noTextContent
        case extractionFailed(Error)
    }

    actor PDFTextExtractor {
        func extractText(from url: URL) async throws -> String {
            // 1. Validate PDF document
            guard let pdfDoc = PDFDocument(url: url) else {
                throw PDFExtractionError.invalidPDF
            }

            // 2. Extract text from all pages
            var fullText = ""
            for pageIndex in 0..<pdfDoc.pageCount {
                guard let page = pdfDoc.page(at: pageIndex) else { continue }

                // PDFPage.string gives plain text
                if let pageText = page.string {
                    fullText += pageText + "\n\n"
                }
            }

            // 3. Validate non-empty
            guard !fullText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
                throw PDFExtractionError.noTextContent
            }

            return fullText.trimmingCharacters(in: .whitespacesAndNewlines)
        }

        // Helper: supported PDF type
        static var supportedTypes: [UTType] {
            [.pdf]
        }
    }
    ```

    Use actor for thread-safety. Extract text from all pages, join with newlines.
    Return clean text suitable for RSVP (10-50k validation happens later in TextValidator).
  </action>
  <verify>Build succeeds, PDFKit imports correctly</verify>
  <done>PDFTextExtractor extracts text from PDF documents</done>
</task>

<task type="auto">
  <name>Task 2: Create DocumentPickerView wrapper</name>
  <files>seed/Presentation/Views/DocumentPickerView.swift</files>
  <action>
    Create SwiftUI wrapper for UIDocumentPickerViewController:

    ```swift
    import SwiftUI
    import UniformTypeIdentifiers

    struct DocumentPickerView: UIViewControllerRepresentable {
        let contentTypes: [UTType]
        let onPick: (URL) -> Void

        func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
            let picker = UIDocumentPickerViewController(forOpeningContentTypes: contentTypes)
            picker.delegate = context.coordinator
            picker.allowsMultipleSelection = false
            return picker
        }

        func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}

        func makeCoordinator() -> Coordinator {
            Coordinator(onPick: onPick)
        }

        class Coordinator: NSObject, UIDocumentPickerDelegate {
            let onPick: (URL) -> Void

            init(onPick: @escaping (URL) -> Void) {
                self.onPick = onPick
            }

            func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
                guard let url = urls.first else { return }
                onPick(url)
            }
        }
    }
    ```

    Standard UIKit bridge pattern for file picker. Returns selected URL via callback.
  </action>
  <verify>Build succeeds, DocumentPickerView compiles</verify>
  <done>DocumentPickerView ready for integration</done>
</task>

<task type="auto">
  <name>Task 3: Add unit test for PDFTextExtractor</name>
  <files>seedTests/PDFTextExtractorTests.swift</files>
  <action>
    Create test file:

    ```swift
    import XCTest
    import PDFKit
    @testable import seed

    final class PDFTextExtractorTests: XCTestCase {
        func testExtractFromValidPDF() async throws {
            let extractor = PDFTextExtractor()

            // Create a test PDF in memory with sample text
            let testText = "Sample PDF content for testing RSVP extraction."
            let testPDF = createTestPDF(with: testText)

            let text = try await extractor.extractText(from: testPDF)
            XCTAssertTrue(text.contains("Sample PDF content"))
            XCTAssertFalse(text.isEmpty)
        }

        func testInvalidPDF() async {
            let extractor = PDFTextExtractor()
            let invalidURL = URL(fileURLWithPath: "/tmp/nonexistent.pdf")

            do {
                _ = try await extractor.extractText(from: invalidURL)
                XCTFail("Should throw invalidPDF error")
            } catch PDFExtractionError.invalidPDF {
                // Expected
            } catch {
                XCTFail("Wrong error type")
            }
        }

        // Helper to create test PDF
        private func createTestPDF(with text: String) -> URL {
            let pdfData = NSMutableData()
            UIGraphicsBeginPDFContextToData(pdfData, CGRect(x: 0, y: 0, width: 612, height: 792), nil)
            UIGraphicsBeginPDFPage()
            text.draw(at: CGPoint(x: 50, y: 50), withAttributes: [.font: UIFont.systemFont(ofSize: 12)])
            UIGraphicsEndPDFContext()

            let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent("test.pdf")
            pdfData.write(to: tempURL, atomically: true)
            return tempURL
        }
    }
    ```

    Test valid PDF extraction and error cases. Use in-memory PDF creation for testing.
  </action>
  <verify>swift test or Cmd+U passes</verify>
  <done>PDFTextExtractor has test coverage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PDFTextExtractor builds without errors
- [ ] DocumentPickerView compiles (UIKit bridge)
- [ ] Tests pass (PDF extraction + error cases)
- [ ] Manual test with sample PDF extracts text
</verification>

<success_criteria>

- All tasks completed
- PDFTextExtractor.extractText(from:) works with PDF files
- DocumentPickerView ready for UI integration
- Clean text output suitable for TextValidator â†’ RSVP flow
- No errors or warnings introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/02-text-input-sources/02-02-SUMMARY.md`
</output>
