---
phase: 01-foundation-rsvp-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - seed/Domain/RSVPEngine.swift
  - seed/Domain/WordTokenizer.swift
  - seed/Domain/SmartAnchor.swift
  - seed/Domain/Models/PlaybackState.swift
autonomous: true

must_haves:
  truths:
    - "Text is split into words with proper tokenization"
    - "Smart anchoring calculates bold letters based on word length"
    - "Playback timing uses CADisplayLink for precision"
    - "Dynamic word duration adjusts based on word length and punctuation"
  artifacts:
    - path: "seed/Domain/RSVPEngine.swift"
      provides: "Core timing engine with CADisplayLink"
      exports: ["RSVPEngine"]
    - path: "seed/Domain/WordTokenizer.swift"
      provides: "Text tokenization using NLTokenizer"
      exports: ["WordTokenizer"]
    - path: "seed/Domain/SmartAnchor.swift"
      provides: "Anchor calculation logic"
      exports: ["SmartAnchor"]
    - path: "seed/Domain/Models/PlaybackState.swift"
      provides: "Playback state model"
      exports: ["PlaybackState"]
  key_links:
    - from: "RSVPEngine"
      to: "CADisplayLink"
      via: "DisplayLink callback for frame-precise timing"
      pattern: "CADisplayLink.*selector"
    - from: "WordTokenizer"
      to: "NLTokenizer"
      via: "Natural language tokenization"
      pattern: "NLTokenizer"
    - from: "SmartAnchor"
      to: "word length logic"
      via: "Character count determines anchor size"
      pattern: "count.*prefix"
---

<objective>
Build core RSVP engine with precision timing, tokenization, and smart anchoring logic.

Purpose: Foundation for word-by-word display with professional timing precision using CADisplayLink.
Output: Domain layer with RSVPEngine, tokenizer, anchor logic, and playback state model.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

Existing code:
@seed/seedApp.swift
@seed/ContentView.swift

**Phase 1 Requirements:**
- RSVP-01: Word-by-word display at fixed position
- RSVP-02: ORP focal point highlighting
- RSVP-03: Smart anchoring (bold 1-3 letters)
- RSVP-04: Real-time WPM adjustment
- RSVP-05: Start/pause/resume controls
- RSVP-06: Seek to specific word
- RSVP-07: Progress indicator
- RSVP-08: CADisplayLink timing precision
- RSVP-09: Dynamic word duration
- RSVP-10: Auto-slow at punctuation
- INPUT-01: Paste from clipboard

**Architecture**: Clean architecture (Domain/Data/Presentation). This plan creates Domain layer.

**Key technical requirements:**
- CADisplayLink for 60fps timing precision (RSVP-08)
- NLTokenizer for proper word boundaries (handles contractions, punctuation)
- Smart anchoring: 1 letter (≤3 chars), 2 letters (4-8 chars), 3 letters (9+ chars)
- Dynamic timing: base interval from WPM, +50% for long words (8+ chars), +100% at sentence-ending punctuation
</context>

<tasks>

<task type="auto">
  <name>Create PlaybackState model</name>
  <files>seed/Domain/Models/PlaybackState.swift</files>
  <action>
Create Observable class PlaybackState with:
- words: [String] (tokenized text)
- currentIndex: Int (which word showing)
- isPlaying: Bool
- wpm: Int (default 300)
- progress: Double (computed: currentIndex/words.count)

Use @Published for SwiftUI reactivity. Include methods: play(), pause(), seek(to:), adjustSpeed(wpm:).
  </action>
  <verify>Build succeeds, no errors</verify>
  <done>PlaybackState compiles with all properties and methods</done>
</task>

<task type="auto">
  <name>Create WordTokenizer with NLTokenizer</name>
  <files>seed/Domain/WordTokenizer.swift</files>
  <action>
Create struct WordTokenizer with static method tokenize(_ text: String) -> [String].

Use NLTokenizer with unit: .word. Handles contractions ("don't" stays intact), removes empty tokens, preserves punctuation as separate tokens where needed for pause logic.

Example: "Hello, world!" → ["Hello", ",", "world", "!"]
  </action>
  <verify>Unit test: tokenize("Hello, world!") returns correct array</verify>
  <done>Tokenizer correctly splits text preserving punctuation context</done>
</task>

<task type="auto">
  <name>Create SmartAnchor logic</name>
  <files>seed/Domain/SmartAnchor.swift</files>
  <action>
Create struct SmartAnchor with:
- static func anchorRange(for word: String) -> Range&lt;String.Index&gt;?

Logic:
- Remove trailing punctuation before counting (e.g., "word!" → count "word")
- 1-3 chars: bold first 1 letter
- 4-8 chars: bold first 2 letters
- 9+ chars: bold first 3 letters
- Return range for AttributedString formatting

Example: "reading" (7 chars) → range covering "re"
  </action>
  <verify>Unit tests: anchorRange for various lengths returns correct ranges</verify>
  <done>Anchor calculation matches smart anchoring spec (RSVP-03)</done>
</task>

<task type="auto">
  <name>Create RSVPEngine with CADisplayLink</name>
  <files>seed/Domain/RSVPEngine.swift</files>
  <action>
Create class RSVPEngine with:
- playbackState: PlaybackState (observed)
- displayLink: CADisplayLink? (frame-precise timer)
- baseInterval: TimeInterval (computed from wpm: 60.0 / Double(wpm))
- currentWordDuration: TimeInterval (dynamic based on word length + punctuation)

Methods:
- start(): Creates displayLink targeting update() selector at 60fps
- stop(): Invalidates displayLink
- update(): Called each frame. Accumulates time, advances word when duration met, applies dynamic timing

Dynamic timing (RSVP-09, RSVP-10):
- Base: 60.0 / wpm seconds per word
- Long word (8+ chars): base * 1.5
- Sentence-ending punctuation (. ! ?): base * 2.0

Wire to playbackState: when isPlaying changes, call start()/stop().
  </action>
  <verify>Build succeeds. Test with mock state: advancing through ["one", "two", "three"] at 300 WPM takes ~0.6s</verify>
  <done>RSVPEngine advances words smoothly using CADisplayLink with dynamic timing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All Swift files compile without errors
- [ ] WordTokenizer unit tests pass
- [ ] SmartAnchor unit tests pass
- [ ] RSVPEngine timing verified with simple playback test
- [ ] PlaybackState model complete with all required properties
</verification>

<success_criteria>
- All tasks completed
- Domain layer established with RSVPEngine, WordTokenizer, SmartAnchor, PlaybackState
- CADisplayLink timing working
- No compilation errors
- Core logic ready for UI integration (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-rsvp-engine/01-01-SUMMARY.md`
</output>
