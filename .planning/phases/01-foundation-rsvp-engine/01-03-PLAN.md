---
phase: 01-foundation-rsvp-engine
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - seed/Presentation/Views/TextInputView.swift
  - seed/Data/TextValidator.swift
autonomous: true

must_haves:
  truths:
    - "User can paste text from clipboard into input field"
    - "Text is validated (non-empty, reasonable length)"
    - "Pasted text triggers RSVP playback preparation"
  artifacts:
    - path: "seed/Presentation/Views/TextInputView.swift"
      provides: "Text input UI with paste support"
      exports: ["TextInputView"]
    - path: "seed/Data/TextValidator.swift"
      provides: "Input validation logic"
      exports: ["TextValidator"]
  key_links:
    - from: "TextInputView"
      to: "UIPasteboard"
      via: "Paste from clipboard action"
      pattern: "UIPasteboard\\.general\\.string"
    - from: "TextInputView"
      to: "TextValidator"
      via: "Validation before accepting text"
      pattern: "TextValidator\\.validate"
---

<objective>
Build text input with clipboard paste support and validation.

Purpose: User entry point for loading text to read via RSVP.
Output: TextInputView with paste functionality and TextValidator for input sanitation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

**Requirements:**
- INPUT-01: User can paste text from clipboard

**User flow:**
1. User opens app (no text loaded yet)
2. User sees TextInputView with "Paste from clipboard" button
3. User taps button → text from UIPasteboard loaded
4. Text validated (not empty, max 50k chars for v1)
5. Valid text passed to RSVPViewModel.loadText()
6. RSVP display becomes active

**Validation rules:**
- Min length: 10 characters (at least 2-3 words)
- Max length: 50,000 characters (~8,000 words, ~30 min read at 300 WPM)
- Trim whitespace, normalize line breaks to spaces

**UI states:**
- Empty: "Paste text to begin reading" placeholder
- Pasted: Show first 100 chars preview + "Load" button
- Loaded: Hide input, show RSVP display (handled in ContentView)
</context>

<tasks>

<task type="auto">
  <name>Create TextValidator</name>
  <files>seed/Data/TextValidator.swift</files>
  <action>
Create struct TextValidator with static method validate(_ text: String) -> Result&lt;String, ValidationError&gt;.

ValidationError enum:
- empty (text is blank)
- tooShort (less than 10 chars)
- tooLong (more than 50,000 chars)

Validation logic:
1. Trim whitespace: text.trimmingCharacters(in: .whitespacesAndNewlines)
2. Check length constraints
3. Normalize: replace multiple spaces/newlines with single space
4. Return .success(normalized) or .failure(error)

Example: "  Hello\n\nworld  " → .success("Hello world")
  </action>
  <verify>Unit tests: validate empty, valid, too short, too long</verify>
  <done>TextValidator correctly validates and normalizes input text</done>
</task>

<task type="auto">
  <name>Create TextInputView</name>
  <files>seed/Presentation/Views/TextInputView.swift</files>
  <action>
Create SwiftUI view TextInputView with @Binding text: String and onLoad callback.

UI components:
1. TextEditor for manual entry (placeholder: "Paste or type text here...")
2. "Paste from Clipboard" button:
   - Reads UIPasteboard.general.string
   - Sets text binding if clipboard has content
   - Shows alert if clipboard empty
3. Character count label (show current/max: "X / 50,000")
4. "Load" button (disabled if text invalid):
   - Validates via TextValidator.validate()
   - Calls onLoad(validatedText) on success
   - Shows alert on validation error

Layout: VStack with padding, Apple HIG spacing. Use .textFieldStyle(.roundedBorder) for text editor.

Accessibility: Labels for VoiceOver, Dynamic Type support.
  </action>
  <verify>Build succeeds, preview shows text editor and buttons</verify>
  <done>TextInputView renders with paste and load functionality</done>
</task>

<task type="auto">
  <name>Integrate TextInputView into ContentView</name>
  <files>seed/ContentView.swift</files>
  <action>
Add state management to ContentView:
- @State private var hasLoadedText = false
- @State private var inputText = ""

Conditional layout:
- If !hasLoadedText: Show TextInputView(text: $inputText, onLoad: { text in viewModel.loadText(text); hasLoadedText = true })
- If hasLoadedText: Show RSVPDisplayView + PlaybackControlsView (existing from Plan 02)

Add "Reset" button (top-right) when hasLoadedText == true to return to input (sets hasLoadedText = false, calls viewModel.reset()).

Remove sample text from Plan 02's .onAppear (input now drives text loading).
  </action>
  <verify>App builds, launches with TextInputView first, then RSVP after load</verify>
  <done>ContentView shows input flow before RSVP playback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TextValidator unit tests pass
- [ ] TextInputView builds and renders correctly
- [ ] ContentView shows input → RSVP flow
- [ ] Paste from clipboard works in simulator (copy text first)
- [ ] Validation errors shown appropriately
- [ ] No build errors
</verification>

<success_criteria>
- All tasks completed
- Text input flow working (paste → validate → load)
- ContentView manages input/playback state transition
- Ready to integrate with Plan 02's RSVP display
- INPUT-01 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-rsvp-engine/01-03-SUMMARY.md`
</output>
